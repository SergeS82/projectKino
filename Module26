Какие бывают основные паттерны навигации в Android;
Для чего нужен Intent и как его использовать;
Как осуществлять перемещение от одного активити к другому;
Как устроена Back&Up навигация;
Как запускать активити в разных режимах;
Запускать активити через startActivityForResult();
Как использовать Navigation из Architecture Components.

Онлайн редактор графов
   https://graphonline.ru/
Интент — это объект-сообщение, который мы можем использовать, чтобы запросить действие у другого компонента приложения.
    val intent = Intent(this, AntotherActivity::class.java)
    startActivity(intent)
    - Implicit/Explicit intents
        startActivity(Intent(this, OtherActivity::class.java)) - явное указание активити - explicit
        startActivity(Intent("other")) - Implicit, указывается action - добавляется на активити, таким образом
            реализуется выбор приложения для обработки пользовательского запроса, например переслать с помощью
val bundle = Bundle()
    bundle.putString("b1", "I'm string from b1")
    bundle.putInt("b2", 2)
    bundle.putLong("b3", 3L)
    bundle.putStringArrayList("b4", arrayListOf("one", "two", "three"))
    bundle.putIntegerArrayList("b4", arrayListOf(1, 2, 3))

    val intent = Intent(this, AntotherActivity::class.java)
    intent.putExtra("bundle", bundle)
    startActivity(intent)
onCreate(savedInstanceState: Bundle?)
    val bundle = intent.extras?.getBundle("bundle")
    if (bundle != null){
        println(bundle.getString("b1"), "not string in b1")
        .....
    }
parcel — посылка
@Parcelize
data class Cat (val name: String, val age: Int) : Parcelable
Parcelize
https://medium.com/the-lazy-coders-journal/easy-parcelable-in-kotlin-the-lazy-coders-way-9683122f4c00
Serialization
https://kotlinlang.org/docs/serialization.html
@Parcelize - классы могу включать в себя другие дата классы тоже должны быть @Parcelize
--
Launch modes
    Режимы запуска (Launch modes) позволяют задавать, каким образом новый инстанс активити будет запущен в текущем таске. Эти режимы могут быть заданы у активити в манифесте, либо в коде флагом у интента.
    В манифесте режим запуска задается у тега <activity> как его атрибут:
    <activity android:name=".MainActivity"
       android:launchMode="standard">:
    Теперь давайте разберём, какие есть параметры у этого атрибута:
        "standard"	Это поведение по умолчанию, то есть, как вы знаете, все активити создаются наверху стека и могут быть созданы несколько раз
        "singleTop"	В общем здесь у нас может быть только один экземпляр активити, но только если он находится наверху. Возможно, это сложно сейчас понять. Давайте так: у нас есть стек активити А-Б-В. Если у активити В стандартный режим запуска, и я попытаюсь ещё раз перейти на это активити, то стек будет выглядеть так: А-Б-В-В. Если у активити В режим запуска "singleTop", то, если я попытаюсь создать еще одно активити В, я буду перенаправлен на уже имеющееся активити В, и стек будет как и прежде: А-Б-В. Но, если при имеющемся стеке я захочу запустить активти Б, то, даже если у него будет режим "singleTop", всё равно будет создан его новый экземпляр, потому что активти Б не наверху стека, и он будет выглядеть так: А-Б-В-Б.
        "singleTask"	Если активити запускается в этом режиме, то создается новый таск, и все активити запущенные из этого активити будут в этом таске. Если такое активити существует в другом таске, то таск с этим активити будет выведен на передний план.
        "singleInstance"	Вот здесь всё просто: у нас в таске может быть только один экземпляр каждого активити.
    Теперь давайте посмотрим, как ставить флаги запуска в коде. Для этого нам при создании интента нужно указать флаг запуска:
    val intent = Intent(this, OtherActivity::class.java)
    intent.flags = Intent.FLAG_ACTIVITY_SINGLE_TOP
    startActivity(intent)
    Вот эти флаги вы будете использовать, чтобы изменить стандартное поведение:
    FLAG_ACTIVITY_NEW_TASK
    Активити будет запущено в новом таске, если таск с таким активити уже существует, то он будет выведен на передний план. Аналогично параметру в манифесте "singleTask".
    FLAG_ACTIVITY_SINGLE_TOP
    Здесь все то же самое, что и для "singleTop", то есть если активити запущено наверху стека, то повторно создаваться не будет, если нет, то будет создан новый экземпляр активити.
    FLAG_ACTIVITY_CLEAR_TOP
    Если активити уже запущено где-то в стеке, то при вызове этого активити он уничтожит все активити, созданные после этого активити, и станет первым в списке. То есть у нас есть стек А-Б-В-Г, активити Б у нас запущено с этим флагом повторно, и стек унас теперь будет А-Б. Из манифеста такое поведение недоступно.